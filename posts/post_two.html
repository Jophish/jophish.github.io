<!doctype HTML>
<html lang="en" style="height: 100%">
  
  <head class="bg">
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">

    <link rel="shortcut icon" href="../assets/images/favicon.ico" type="image/x-icon"/ >
    <link rel="me" href="https://github.com/jophish" />
    <link rel="me" href="https://soundcloud.com/morningsounds" />
    <link rel="me" href="https://mornings.bandcamp.com/" />
    <title> Writing a Tiny x86 Bootloader - Joe Bergeron </title>


    
    <link rel="stylesheet" href="../assets/css/bootstrap.css" type="text/css" />
    <link rel="stylesheet" href="../assets/css/custom.css" type="text/css" />
    <link rel="stylesheet" href="../assets/css/custom_colors.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../assets/css/codehilite.css">
    
    <script type="text/javascript" src="../assets/js/jquery.js"></script>
    <script type="text/javascript" src="../assets/js/bootstrap.js"></script>
    <script type="text/javascript" src="../assets/js/custom.js"></script>
    <script type="text/javascript" src="../assets/js/analytics.js"></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,200,300,200italic,300italic,400italic' rel='stylesheet' type='text/css'>
    
    <link href="../assets/css/simple-sidebar.css" rel="stylesheet">

    
    

    
  </head>
  
  <body class="bg" style="height: 100%">
    <!-- sidebar here-->
    <div class="container-fluid bg" style="width=10%; height: 100%">
      <div class="row bg" style="height: auto" id="mainRow">

	  <div class="col-sm-1 sidebar" style="width=10%; max-width: 100px" id="sidebar">

	    <ul class="sidebar-nav">
              <li class="sidebar-button">
		<a href="../about.html">a b o u t</a>
              </li>
              <li class="sidebar-button">
		<a href="../index.html">p o s t s</a>
              </li>
              <li class="sidebar-button">
		<a href="../projects.html">p r o j e c t s</a>
              </li>
	    </ul>
	  </div>

	<div class="col-sm-11 bg stuff" style="height: auto" id="stuff">
	  <div class="container-fluid" style="width: 100%; height: 100%">
	    <div id="header-stuff">
	      <div class="row bg">
		<div class="col-sm-3 bg"></div>
		<h1 id="title" class="text-center col-sm-6 bg" style=""><a href="../index.html">j a b</a></h1>
		<div class="col-sm-3 bg"></div>
	      </div>

	      <div class="row bg">
		<div class="col-sm-2 bg"></div>
	      
		<h3 class="text-center col-sm-8 bg" style="padding: 0px; line-height: 5px"><hr id="vert-bar""></hr></h3>
		<div class="col-sm-2 bg"></div>
	      </div>
	    </div>
	    <div class="col-sm-2 bg"></div>
	    <div class="text-center col-sm-8 bg" style="height: 100%; padding: 0px;">
	      <div id ="main-body"class="container-fluid textPost" style="height: 100%; font-family: 'Source Sans Pro';">
		<div class="text-post"><style scoped>img.latex-inline { vertical-align: middle; }</style>
<h1>Writing a Tiny x86 Bootloader</h1>
<p><br></br>
<i>All the code/files from this post are available on my <a href="https://github.com/Jophish/tiny-bootstrap">Github</a>.</i>
<br></br></p>
<p><i> Edit: After some discussion by the <a href="https://news.ycombinator.com/item?id=13268781">good people on Hacker News</a>, it's become clear that when in 16-bit real mode, it's best to use 2-byte registers bp, sp, instead of the 4-byte esb, esp. The article and code have been updated to reflect this.</i></p>
<p><br></br>
It might be from being stuck at home with nothing to do over break, or it might be from an <em>actual interest</em> in low-level systems design, but I've taken it upon myself to learn more about OS implementation, starting with the bootloader. So, here we go. All of this information exists in various other places on the web, but there's no better way to learn than by teaching, right? Either way, this piece should serve as primer on what exactly a bootloader does and how to implement a relatively simple one (compared to a beast like <a href="https://en.wikipedia.org/wiki/GNU_GRUB">GRUB</a> which is ostensibly its own little operating system).</p>
<h2>What is a bootloader?</h2>
<p>When a computer boots up, the job of getting from nothing to a functioning operating system involves a number of steps. The first thing that happens on an x86 PC is the operation of the BIOS. We'll eschew the discussion of the intricacies of how the BIOS works, but here's what you need to know. When you turn your computer on, the processor immediately looks at physical address 0xFFFFFFF0 for the BIOS code, which is generally on some read-only piece of ROM somewhere in your computer. The BIOS then POSTs, and searches for acceptable boot media. The BIOS accepts some medium as an acceptable boot device if its <em>boot sector</em>, the first 512 bytes of the disk are readable and end in the exact bytes 0x55AA, which constitutes the boot signature for the medium. If the BIOS deems some drive bootable, then it loads the first 512 bytes of the drive into memory address 0x007C00, and transfers program control to this address with a jump instruction to the processor.</p>
<p>Most modern BIOS programs are pretty robust, for example, if the BIOS recognizes several drives with appropriate boot sectors, it will boot from the one with the highest pre-assigned priority; which is exactly why most computers default to booting from USB rather than hard disk if a bootable USB drive is inserted on boot.</p>
<p>Typically, the role of the boot sector code is to load a larger, "real" operating system stored somewhere else on non-volatile memory. In actuality, this is a multi-step process. For example, <a href="https://en.wikipedia.org/wiki/Master_boot_record">Master Boot Record</a>, or MBR, is a very common (though now becoming more and more deprecated) boot sector standard for partioned storage devices. Since the boot sector may contain a maximum of 512 bytes of data, an MBR bootloader often simply does the job of passing control to a different, larger bootloader stored somewhere else on disk, whose job in turn is to actually load the operating system (<a href="https://en.wikipedia.org/wiki/Chain_loading">chain-loading</a>). Right now, though, we won't concern ourselves with all this; the goal here isn't to write an operating system (saving that one for another post), but just to get the computer to spit something out onto the screen of our choosing.</p>
<p>It's also important to note that the execution is passed over to bootstrap code while the processor is in <a href="https://en.wikipedia.org/wiki/Real_mode">real mode</a>, rather than <a href="https://en.wikipedia.org/wiki/Protected_mode">protected mode</a>, which means that (among other things,) access to all of those great features of operating systems that you know and love is out the window. On the other hand, it means that we can directly access the BIOS <a href="https://en.wikipedia.org/wiki/BIOS_interrupt_call">interrupt calls</a>, which offer some neat low-level functionality.</p>
<p>So, where to begin? I decided to use <a href="https://en.wikipedia.org/wiki/Netwide_Assembler">NASM</a>, a pretty ubiquitous flavor of assembly, for this project. As far as testing goes, it's very much possible to just dd the compiled assembly onto the first 512 bytes of a USB drive and boot the computer from that, but that doesn't have a very fast turnaround, no? <a href="https://en.wikipedia.org/wiki/Bochs">Bochs</a> is a neat little x86 IBM-PC compatible emulator which has a bunch of useful features; we'll use this for testing.</p>
<h2>Getting Started</h2>
<p>Go ahead and download the NASM compiler and Bochs. I use Arch, so pacman is my package manager.</p>
<div class="codehilite"><pre><span></span>sudo pacman -S nasm bochs
</pre></div>


<p>Just for fun, let's start by writing a little stack for our bootloader to use. x86 processors have a number of <a href="http://wiki.osdev.org/Segmentation"><em>segment registers</em></a>, which are used to store the beggining of a 64k segment of memory. In real mode, memory is addressed using a <em>logical address</em>, rather than the physical address. The logical address of a piece of memory consists of the 64k segment it resides in, as well as its offset from the beginning of that segment. The 64k segment of a logical address should be divided by 16, so, given a logical address beginning at 64k segment A, with offset B, the reconstructed physical address would be A*0x10 + B.</p>
<p>For example, the processor has a DS register for the data segment. Since our code resides at 0x7C00, the data segment may begin at 0x7C0, which we can set with</p>
<div class="codehilite"><pre><span></span><span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span> <span class="mi">0x7C0</span>
<span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span> <span class="no">ax</span>
</pre></div>


<p>We have to load the segment into another register (here it's ax) first; we can't directly stick it in the segment register. Let's start the storage for the stack directly after the 512 bytes of the bootloader. Since the bootloader extends from 0x7C00 for 512 bytes to 0x7E00, the stack segment, SS, will be 0x7E0.</p>
<div class="codehilite"><pre><span></span><span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span> <span class="mi">0x7E0</span>
<span class="nf">mov</span> <span class="no">ss</span><span class="p">,</span> <span class="no">ax</span>
</pre></div>


<p>On x86 architectures, the stack pointer decreases, so we must set the initial stack pointer to a number of bytes past the stack segment equal to the desired size of the stack. Since the stack segment can address 64k of memory, let's make an 8k stack, by setting SP to 0x2000.</p>
<div class="codehilite"><pre><span></span><span class="nf">mov</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">0x2000</span>
</pre></div>


<p>We're now free to use the standard calling convention in order to safely pass control over to different functions. We can use <tt>push</tt> in order to push <em>caller-saved</em> registers on to the stack, pass parameters to the callee again with <tt>push</tt>, and then use <tt>call</tt> to save the current program counter to the stack, and perform an unconditional jump to the given label.</p>
<p>Alright, now that all that is out of the way, let's figure out a way to clear the screen, move the pointer, and write some text. This is where real mode and BIOS interrupt calls come in to play. By storing certain registers with certain parameters and then sending a particular opcode to the BIOS as an interrupt, we can do a bunch of cool stuff. For example, by storing 0x07 in the AH register and sending interrupt code 0x10 to the BIOS, we can scroll the window down by a number of rows. See the spec <a href="http://www.ctyme.com/intr/rb-0097.htm">here</a>. Note that the registers AH and AL refer to the most and least significant bytes of the 16 bit register AX. Thus, we could effectively update both their values at once by simply pushing a 16 bit value to AX, however, we'll opt for the clearer approach of updating each 1-byte subregister at a time.</p>
<p>If you look at the spec, you'll see that we need to set AH to 0x07, and AL to 0x00. the value of register BH refers to the <a href="https://en.wikipedia.org/wiki/BIOS_color_attributes">BIOS color attribute</a>, which for our purposes will be black background (0x0) behind light-gray (0x7) text, so we must set BH to 0x07. Registers CX and DX refer to the subsection of the screen that we want to clear. The standard number of character rows/cols here is 25/80, so we set CH and CL to 0x00 to set (0,0) as the top left of the screen to clear, and DH as 0x18 = 24, DL as 0x4f = 79. Putting this all together in a function, we get the following snippet.</p>
<div class="codehilite"><pre><span></span><span class="nl">clearscreen:</span>
    <span class="nf">push</span> <span class="no">bp</span>
    <span class="nf">mov</span> <span class="no">bp</span><span class="p">,</span> <span class="no">sp</span>
    <span class="nf">pusha</span>

    <span class="nf">mov</span> <span class="no">ah</span><span class="p">,</span> <span class="mi">0x07</span>        <span class="c"># tells BIOS to scroll down window</span>
    <span class="nf">mov</span> <span class="no">al</span><span class="p">,</span> <span class="mi">0x00</span>        <span class="c"># clear entire window</span>
    <span class="nf">mov</span> <span class="no">bh</span><span class="p">,</span> <span class="mi">0x07</span>        <span class="c"># white on black</span>
    <span class="nf">mov</span> <span class="no">cx</span><span class="p">,</span> <span class="mi">0x00</span>        <span class="c"># specifies top left of screen as (0,0)</span>
    <span class="nf">mov</span> <span class="no">dh</span><span class="p">,</span> <span class="mi">0x18</span>        <span class="c"># 18h = 24 rows of chars</span>
    <span class="nf">mov</span> <span class="no">dl</span><span class="p">,</span> <span class="mi">0x4f</span>        <span class="c"># 4fh = 79 cols of chars</span>
    <span class="nf">int</span> <span class="mi">0x10</span>            <span class="c"># calls video interrupt</span>

    <span class="nf">popa</span>
    <span class="nf">mov</span> <span class="no">sp</span><span class="p">,</span> <span class="no">bp</span>
    <span class="nf">pop</span> <span class="no">bp</span>
    <span class="nf">ret</span>
</pre></div>


<p>The overhead at the beginning and end of the subroutine allows us to adhere to the standard calling convention between caller and callee. <tt>pusha</tt> and <tt>popa</tt> push and pop all general registers on and off the stack. We save the caller's base pointer (4 bytes), and update the base pointer with the new stack pointer. At the very end, we essentially mirror this process.</p>
<p>Nice. Now let's write a subroutine for moving the cursor to an arbitrary (row,col) position on the screen. <a href="http://www.ctyme.com/intr/rb-0087.htm">Int 10/AH=02h</a> does this nicely. This subroutine will be slightly different, since we'll need to pass it an argument. According to the spec, we must set register DX to a two byte value, the first representing the desired row, and second the desired column. AH has gotta be 0x02, BH represents the page number we want to move the cursor to. This parameter has to do with the fact that the BIOS allows you to draw to off-screen pages, in order to facilitate smoother visual transitions by rendering off-screen content before it is shown to the user. This is called <em>multiple</em> or <em>double buffering</em>. We don't really care about this, however, so we'll just use the default page of 0.</p>
<p>Putting it all together, we have the following subroutine.</p>
<div class="codehilite"><pre><span></span><span class="nl">movecursor:</span>
    <span class="nf">push</span> <span class="no">bp</span>
    <span class="nf">mov</span> <span class="no">bp</span><span class="p">,</span> <span class="no">sp</span>
    <span class="nf">pusha</span>

    <span class="nf">mov</span> <span class="no">dx</span><span class="p">,</span> <span class="p">[</span><span class="no">bp</span><span class="err">+</span><span class="mi">4</span><span class="p">]</span>      <span class="c"># get the argument from the stack. |bp| = 2, |arg| = 2</span>
    <span class="nf">mov</span> <span class="no">ah</span><span class="p">,</span> <span class="mi">0x02</span>        <span class="c"># set cursor position</span>
    <span class="nf">mov</span> <span class="no">bh</span><span class="p">,</span> <span class="mi">0x00</span>        <span class="c"># page 0 - doesn&#39;t matter, we&#39;re not using double-buffering</span>
    <span class="nf">int</span> <span class="mi">0x10</span>

    <span class="nf">popa</span>
    <span class="nf">mov</span> <span class="no">sp</span><span class="p">,</span> <span class="no">bp</span>
    <span class="nf">pop</span> <span class="no">bp</span>
    <span class="nf">ret</span>
</pre></div>


<p>The only thing that might look unusual is the <strong>mov dx, [bp+4]</strong>. This moves the argument we passed into the DX register. The reason we offset by 4 is that the contents of bp takes up 2 bytes on the stack, and the argument takes up two bytes, so we have to offset a total of 4 bytes from the actual address of bp. Note also that the caller has the responsibility to clean the stack after the callee returns, which amounts to removing the arguments from the top of the stack by moving the stack pointer.</p>
<p>The final subroutine we want to write is simply one that, given a pointer to the beginning of a string, prints that string to the screen beginning at the current cursor position. Using the video interrupt code with <a href="http://www.ctyme.com/intr/rb-0106.htm">AH=0Eh</a> works nicely. First off, we can define some data and store a pointer to its starting address with something that looks like this.</p>
<div class="codehilite"><pre><span></span>    <span class="nl">msg:</span>    <span class="nf">db</span> <span class="err">&quot;</span><span class="no">Oh</span> <span class="no">boy</span> <span class="no">do</span> <span class="no">I</span> <span class="no">sure</span> <span class="no">love</span> <span class="no">assembly</span><span class="p">!</span><span class="err">&quot;</span><span class="p">,</span> <span class="mi">0</span>
</pre></div>


<p>The 0 at the end terminates the string with a null character, so we'll know when the string is done. We can reference the address of this string with <em>msg</em>. Then, the rest is pretty much like what we just saw with movecursor. We use some more labels and a conditional jump, but at risk of being too verbose, understanding the code is left as an excercise to the reader ;).</p>
<div class="codehilite"><pre><span></span>    <span class="nl">print:</span>
        <span class="nf">push</span> <span class="no">bp</span>
        <span class="nf">mov</span> <span class="no">bp</span><span class="p">,</span> <span class="no">sp</span>
        <span class="nf">pusha</span>
        <span class="nf">mov</span> <span class="no">si</span><span class="p">,</span> <span class="p">[</span><span class="no">bp</span><span class="err">+</span><span class="mi">4</span><span class="p">]</span>      <span class="c"># grab the pointer to the data</span>
        <span class="nf">mov</span> <span class="no">bh</span><span class="p">,</span> <span class="mi">0x00</span>        <span class="c"># page number, 0 again</span>
        <span class="nf">mov</span> <span class="no">bl</span><span class="p">,</span> <span class="mi">0x00</span>        <span class="c"># foreground color, irrelevant - in text mode</span>
        <span class="nf">mov</span> <span class="no">ah</span><span class="p">,</span> <span class="mi">0x0E</span>        <span class="c"># print character to TTY</span>
     <span class="nl">.char:</span>
         <span class="nf">mov</span> <span class="no">al</span><span class="p">,</span> <span class="p">[</span><span class="no">si</span><span class="p">]</span>       <span class="c"># get the current char from our pointer position</span>
         <span class="nf">add</span> <span class="no">si</span><span class="p">,</span> <span class="mi">1</span>          <span class="c"># keep incrementing si until we see a null char</span>
         <span class="nf">or</span> <span class="no">al</span><span class="p">,</span> <span class="mi">0</span>
         <span class="nf">je</span> <span class="no">.return</span>         <span class="c"># end if the string is done</span>
         <span class="nf">int</span> <span class="mi">0x10</span>           <span class="c"># print the character if we&#39;re not done</span>
         <span class="nf">jmp</span> <span class="no">.char</span>          <span class="c"># keep looping</span>
     <span class="nl">.return:</span>
         <span class="nf">popa</span>
         <span class="nf">mov</span> <span class="no">sp</span><span class="p">,</span> <span class="no">bp</span>
         <span class="nf">pop</span> <span class="no">bp</span>
         <span class="nf">ret</span>
</pre></div>


<p>And that'll just about do it folks. Plugging everything we have so far together, we get the following <em>real life</em> bootloader.</p>
<div class="codehilite"><pre><span></span>    <span class="nf">bits</span> <span class="mi">16</span>

    <span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span> <span class="mi">0x07C0</span>
    <span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span> <span class="no">ax</span>
    <span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span> <span class="mi">0x07E0</span>      <span class="c"># 07E0h = (07C00h+200h)/10h, beginning of stack segment.</span>
    <span class="nf">mov</span> <span class="no">ss</span><span class="p">,</span> <span class="no">ax</span>
    <span class="nf">mov</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">0x2000</span>      <span class="c"># 8k of stack space.</span>

    <span class="nf">call</span> <span class="no">clearscreen</span>

    <span class="nf">push</span> <span class="mi">0x0000</span>
    <span class="nf">call</span> <span class="no">movecursor</span>
    <span class="nf">add</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">2</span>

    <span class="nf">push</span> <span class="no">msg</span>
    <span class="nf">call</span> <span class="no">print</span>
    <span class="nf">add</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">2</span>

    <span class="nf">cli</span>
    <span class="nf">hlt</span>

    <span class="nl">clearscreen:</span>
        <span class="nf">push</span> <span class="no">bp</span>
        <span class="nf">mov</span> <span class="no">bp</span><span class="p">,</span> <span class="no">sp</span>
        <span class="nf">pusha</span>

        <span class="nf">mov</span> <span class="no">ah</span><span class="p">,</span> <span class="mi">0x07</span>        <span class="c"># tells BIOS to scroll down window</span>
        <span class="nf">mov</span> <span class="no">al</span><span class="p">,</span> <span class="mi">0x00</span>        <span class="c"># clear entire window</span>
        <span class="nf">mov</span> <span class="no">bh</span><span class="p">,</span> <span class="mi">0x07</span>        <span class="c"># white on black</span>
        <span class="nf">mov</span> <span class="no">cx</span><span class="p">,</span> <span class="mi">0x00</span>        <span class="c"># specifies top left of screen as (0,0)</span>
        <span class="nf">mov</span> <span class="no">dh</span><span class="p">,</span> <span class="mi">0x18</span>        <span class="c"># 18h = 24 rows of chars</span>
        <span class="nf">mov</span> <span class="no">dl</span><span class="p">,</span> <span class="mi">0x4f</span>        <span class="c"># 4fh = 79 cols of chars</span>
        <span class="nf">int</span> <span class="mi">0x10</span>            <span class="c"># calls video interrupt</span>

        <span class="nf">popa</span>
        <span class="nf">mov</span> <span class="no">sp</span><span class="p">,</span> <span class="no">bp</span>
        <span class="nf">pop</span> <span class="no">bp</span>
        <span class="nf">ret</span>

    <span class="nl">movecursor:</span>
        <span class="nf">push</span> <span class="no">bp</span>
        <span class="nf">mov</span> <span class="no">bp</span><span class="p">,</span> <span class="no">sp</span>
        <span class="nf">pusha</span>

        <span class="nf">mov</span> <span class="no">dx</span><span class="p">,</span> <span class="p">[</span><span class="no">bp</span><span class="err">+</span><span class="mi">4</span><span class="p">]</span>  <span class="c"># get the argument from the stack. |bp| = 2, |arg| = 2</span>
        <span class="nf">mov</span> <span class="no">ah</span><span class="p">,</span> <span class="mi">0x02</span>        <span class="c"># set cursor position</span>
        <span class="nf">mov</span> <span class="no">bh</span><span class="p">,</span> <span class="mi">0x00</span>        <span class="c"># page 0 - doesn&#39;t matter, we&#39;re not using double-buffering</span>
        <span class="nf">int</span> <span class="mi">0x10</span>

        <span class="nf">popa</span>
        <span class="nf">mov</span> <span class="no">sp</span><span class="p">,</span> <span class="no">bp</span>
        <span class="nf">pop</span> <span class="no">bp</span>
        <span class="nf">ret</span>

    <span class="nl">print:</span>
        <span class="nf">push</span> <span class="no">bp</span>
        <span class="nf">mov</span> <span class="no">bp</span><span class="p">,</span> <span class="no">sp</span>
        <span class="nf">pusha</span>
        <span class="nf">mov</span> <span class="no">si</span><span class="p">,</span> <span class="p">[</span><span class="no">bp</span><span class="err">+</span><span class="mi">4</span><span class="p">]</span>      <span class="c"># grab the pointer to the data</span>
        <span class="nf">mov</span> <span class="no">bh</span><span class="p">,</span> <span class="mi">0x00</span>        <span class="c"># page number, 0 again</span>
        <span class="nf">mov</span> <span class="no">bl</span><span class="p">,</span> <span class="mi">0x00</span>        <span class="c"># foreground color, irrelevant - in text mode</span>
        <span class="nf">mov</span> <span class="no">ah</span><span class="p">,</span> <span class="mi">0x0E</span>        <span class="c"># print character to TTY</span>
    <span class="nl">.char:</span>
        <span class="nf">mov</span> <span class="no">al</span><span class="p">,</span> <span class="p">[</span><span class="no">si</span><span class="p">]</span>        <span class="c"># get the current char from our pointer position</span>
        <span class="nf">add</span> <span class="no">si</span><span class="p">,</span> <span class="mi">1</span>           <span class="c"># keep incrementing si until we see a null char</span>
        <span class="nf">or</span> <span class="no">al</span><span class="p">,</span> <span class="mi">0</span>
        <span class="nf">je</span> <span class="no">.return</span>          <span class="c"># end if the string is done</span>
        <span class="nf">int</span> <span class="mi">0x10</span>            <span class="c"># print the character if we&#39;re not done</span>
        <span class="nf">jmp</span> <span class="no">.char</span>           <span class="c"># keep looping</span>
    <span class="nl">.return:</span>
        <span class="nf">popa</span>
        <span class="nf">mov</span> <span class="no">sp</span><span class="p">,</span> <span class="no">bp</span>
        <span class="nf">pop</span> <span class="no">bp</span>
        <span class="nf">ret</span>


    <span class="nl">msg:</span>    <span class="nf">db</span> <span class="err">&quot;</span><span class="no">Oh</span> <span class="no">boy</span> <span class="no">do</span> <span class="no">I</span> <span class="no">sure</span> <span class="no">love</span> <span class="no">assembly</span><span class="p">!</span><span class="err">&quot;</span><span class="p">,</span> <span class="mi">0</span>

<span class="nf">times</span> <span class="mi">510</span><span class="p">-(</span><span class="err">&lt;</span><span class="no">img</span> <span class="no">class</span><span class="err">=&#39;</span><span class="no">latex-inline</span> <span class="no">math-true</span><span class="err">&#39;</span> <span class="no">alt</span><span class="err">=&#39;&#39;</span> <span class="no">id</span><span class="err">=&#39;</span><span class="no">_1</span><span class="err">&#39;</span> <span class="no">src</span><span class="err">=&#39;</span><span class="no">data</span><span class="p">:</span><span class="no">image</span><span class="err">/</span><span class="no">png</span><span class="err">;</span><span class="no">base64</span><span class="p">,</span><span class="no">iVBORw0KGgoAAAANSUhEUgAAAAoAAAABAgMAAACam9ftAAAADFBMVEX</span><span class="err">///</span><span class="mi">8</span><span class="no">AAAAAAAAAAAD4jAJNAAAAA3RSTlMAZplAAiMfAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADElEQVQI12PIWtUAAAMWAZX9ZpagAAAAAElFTkSuQmCC</span><span class="err">&#39;&gt;</span><span class="no">$</span><span class="p">)</span> <span class="no">db</span> <span class="mi">0</span>
<span class="nf">dw</span> <span class="mi">0xAA55</span>
</pre></div>


<p>Some things might not be familiar in there. The first line of the program tells the assembler that we're working in 16-bit real mode. The lines <em>cli</em> and <em>hlt</em> after we finish printing tell the processor not to accept interrupts and to halt processing. Finally, remember that the code in a bootsector has to be exactly 512 bytes, ending in 0xAA55? The last two lines pad the binary to a length of 510 bytes, and make sure the file ends with the appropriate boot signature.</p>
<p>That's it folks.</p>
<p><br></br></p>
<p>Oh, did you actually want to <em>run</em> the code? Go ahead and save the code above into a file, say <em>boot.asm</em>. (Actually, you'd be better off just grabbing it from <a href="https://github.com/Jophish/tiny-bootstrap">Github</a>, since my syntax highlighter for assembly thinks # means a comment, but NASM thinks ; means a comment. Oh well). </p>
<p>Then, the following command generates a nice binary from our asm bootloader code.</p>
<div class="codehilite"><pre><span></span>nasm -f bin boot.asm -o boot.com
</pre></div>


<p>Then, in the same directory, whip up a file called <em>bochsrc.txt</em>, and fill it up with the following</p>
<div class="codehilite"><pre><span></span>megs: 32
romimage: <span class="nv">file</span><span class="o">=</span>/usr/share/bochs/BIOS-bochs-latest, <span class="nv">address</span><span class="o">=</span>0xfffe0000
vgaromimage: <span class="nv">file</span><span class="o">=</span>/usr/share/bochs/VGABIOS-lgpl-latest
floppya: <span class="nv">1_44</span><span class="o">=</span>boot.com, <span class="nv">status</span><span class="o">=</span>inserted
boot: a
log: bochsout.txt
mouse: <span class="nv">enabled</span><span class="o">=</span>0
display_library: x, <span class="nv">options</span><span class="o">=</span><span class="s2">&quot;gui_debug&quot;</span>
</pre></div>


<p>This just contains some simple config stuff for Bochs, nothing too fancy. Basically you're just telling Bochs that your boot medium is a 1.44 Meg floppy with your binary loaded on it. Finally, you can just call</p>
<div class="codehilite"><pre><span></span>bochs -f bochsrc.txt
</pre></div>


<p>to run Bochs using the config file you just wrote, and <em>voila</em>, you should see something along the lines of this.</p>
<p><img src="../assets/images/bochs.png" class="postImage"></img></p>
<p>Wow. Pretty boring, huh? If you have a USB drive laying around anywhere, you can do something marginally cooler. Plug that puppy in and find out where it lives (use dmesg or something). Mine was on <em>/dev/sdb</em>. Using <em>dd</em>, run</p>
<div class="codehilite"><pre><span></span>sudo dd <span class="k">if</span><span class="o">=</span>boot.com <span class="nv">of</span><span class="o">=</span>/dev/sdb <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="nv">count</span><span class="o">=</span>1
</pre></div>


<p>This will copy the first 512 bytes of your bootloader (read: all of it), to the first 512 bytes of your USB drive. If you want to make sure everything copied over all well and good, you can let <em>if=/dev/sdb</em> and <em>of=test.com</em>, then diff the two files. They should be identical. Then, it's just a matter of restarting your computer (and potentially changing boot priority to boot from USB first), and you should see the same boring text you see in an emulator just minutes ago. Well done.</p>
<p>It should be said, again, that most <em>real</em> bootloaders are orders of magnitutde more complex than this one, however I think this is a pretty good proof of concept/learning tool. <em>Hopefully</em> you learned something from this - I certainly did, even if the end result was far more underwhelming than I expected it to be. </p>
	      </div>
	    </div>
	    <div class="col-sm-2 bg"></div>
	  </div>
	  
	</div>
	
      </div>

    </div>
    
  </body>

</html>

